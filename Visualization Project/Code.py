# -*- coding: utf-8 -*-
"""Code_Perla_Ramdas_Hameed_Sharma.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cmsMlDjaChKIF9ZWDjDhaA-JRGStbP_i
"""

###################################################################################

#Clients dataset analysis
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
from sklearn.cluster import KMeans
from sklearn.manifold import TSNE
import plotly.graph_objs as go
import plotly .offline as offline
import plotly.figure_factory as ff


dataset= pd.read_csv('Clients.csv', skipinitialspace=False)
dataset
dataset['job']=dataset['job'].map({'blue-collar':0,'management':2,'technician':3,'admin.':4,'services':5,'retired':6,'self-employed':7,'entrepreneur':8,'unemployed':9,'housemaid':10,'student':11})
dataset['marital']=dataset['marital'].map({'married':0,'single':1,'divorced':2})
dataset['education']=dataset['education'].map({'secondary':2,'tertiary':3,'primary':1})
from sklearn.preprocessing import LabelBinarizer
l_bn=LabelBinarizer()
y=dataset['default']
x=dataset['housing']
z=dataset['personal']
w=dataset['term']
dataset['default']=l_bn.fit_transform(y)
dataset['housing']=l_bn.fit_transform(x)
dataset['personal']=l_bn.fit_transform(z)
dataset['term']=l_bn.fit_transform(w)
dataset
bins=[0,20,40,60,80,100]
names=[0,1,2,3,4]
dataset['age']=pd.cut(dataset['age'],bins, labels=names)
bins=[-8019,0,20000,50000,110000]
names=[0,1,2,3]
dataset['balance']=pd.cut(dataset['balance'], bins, labels=names)
dataset[['age']]=dataset[['age']].astype('int64')
dataset=dataset[~dataset['balance'].isnull()]
dataset[['balance']]=dataset[['balance']].astype('int64')
dataset['balance'].value_counts()
# Plotting Correlation Heatmap
corrs = dataset.corr()
figure = ff.create_annotated_heatmap(
         z=corrs.values,
         x=list(corrs.columns),
         y=list(corrs.index),
         annotation_text=corrs.round(2).values,
         showscale=True)
offline.plot(figure,filename='corrheatmap.html')

X=dataset

#Personal Data
subset1 = X[['age','marital','education']]
subset2 = X[['job','personal','housing','default','balance','term']]
subset3 = X[['marital','job', 'default', 'balance']]

feature_scaler = StandardScaler()
X1 = feature_scaler.fit_transform(subset1)
X2 = feature_scaler.fit_transform(subset2)
X3 = feature_scaler.fit_transform(subset3)

# Analysis on Personal Data
# Finding the number of clusters (K) - Elbow Plot Method
inertia = []
for i in range(1,11):
    kmeans = KMeans(n_clusters = i, random_state = 100)
    kmeans.fit(X1)
    inertia.append(kmeans.inertia_)

plt.plot(range(1, 11), inertia)
plt.title('The Elbow Plot')
plt.xlabel('Number of clusters')
plt.ylabel('Inertia')
plt.show()

# Running KMeans to generate labels
kmeans = KMeans(n_clusters = 3)
kmeans.fit(X1)

# Implementing t-SNE to visualize dataset
tsne = TSNE(n_components = 2, perplexity =50,n_iter=4000)
x_tsne = tsne.fit_transform(X1)

age = list(X['age'])
marital = list(X['marital'])
education = list(X['education'])
data = [go.Scatter(x=x_tsne[:,0], y=x_tsne[:,1], mode='markers',
                    marker = dict(color=kmeans.labels_, colorscale='Rainbow', opacity=0.5),
                                text=[f'age: {a}; marital: {b}; education:{c}'  for a,b,c in list(zip(age,marital,education))],
                                      hoverinfo='text')]

layout = go.Layout(title = 't-SNE Dimensionality Reduction', width = 700, height = 700,
                    xaxis = dict(title='First Dimension'),
                    yaxis = dict(title='Second Dimension'))
fig = go.Figure(data=data, layout=layout)
offline.plot(fig,filename='t-SNE.html')
                   

inertia = []
for i in range(1,11):
    kmeans = KMeans(n_clusters = i, random_state = 100)
    kmeans.fit(X2)
    inertia.append(kmeans.inertia_)

plt.plot(range(1, 11), inertia)
plt.title('The Elbow Plot')
plt.xlabel('Number of clusters')
plt.ylabel('Inertia')
plt.show()


# Running KMeans to generate labels
kmeans = KMeans(n_clusters = 2)
kmeans.fit(X2)

# Implementing t-SNE to visualize dataset
tsne = TSNE(n_components = 2, perplexity=50,n_iter=4000)
x_tsne = tsne.fit_transform(X2)

js = list(X['job'])
defa = list(X['default'])
bala = list(X['balance'])
housing=list(X['housing'])
personal=list(X['personal'])
term=list(X['term'])

data = [go.Scatter(x=x_tsne[:,0], y=x_tsne[:,1], mode='markers',
                    marker = dict(color=kmeans.labels_, colorscale='Rainbow', opacity=0.5),
                                text=[f'job: {a}; default: {b}; balance:{c}, housing:{d}, personal:{e}, term:{f}' for a,b,c,d,e in list(zip(js, defa, bala, housing, personal, term))],
                                hoverinfo='text')]

layout = go.Layout(title = 't-SNE Dimensionality Reduction', width = 1000, height = 700,
                    xaxis = dict(title='First Dimension'),
                    yaxis = dict(title='Second Dimension'))
fig = go.Figure(data=data, layout=layout)
offline.plot(fig,filename='t-SNE2.html')

# Analysis on Personal Data
# Finding the number of clusters (K) - Elbow Plot Method
inertia = []
for i in range(1,11):
    kmeans = KMeans(n_clusters = i, random_state = 100)
    kmeans.fit(X3)
    inertia.append(kmeans.inertia_)

plt.plot(range(1, 11), inertia)
plt.title('The Elbow Plot')
plt.xlabel('Number of clusters')
plt.ylabel('Inertia')
plt.show()

# Running KMeans to generate labels
kmeans = KMeans(n_clusters = 3)
kmeans.fit(X3)

# Implementing t-SNE to visualize dataset
tsne = TSNE(n_components = 2, perplexity =50,n_iter=4000)
x_tsne = tsne.fit_transform(X3)

marital = list(X['marital'])
job = list(X['job'])
default = list(X['default'])
balance = list(X['balance'])
data = [go.Scatter(x=x_tsne[:,0], y=x_tsne[:,1], mode='markers',
                    marker = dict(color=kmeans.labels_, colorscale='Rainbow', opacity=0.5),
                                text=[f'marital: {a}; job: {b}; default:{c}; balance:{d}'  for a,b,c,d in list(zip(marital,job,default, balance))],
                                      hoverinfo='text')]

layout = go.Layout(title = 't-SNE Dimensionality Reduction', width = 700, height = 700,
                    xaxis = dict(title='First Dimension'),
                    yaxis = dict(title='Second Dimension'))
fig = go.Figure(data=data, layout=layout)
offline.plot(fig,filename='t-SNE3.html')




##################################################################                     



#Patches dataset analysis
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
from sklearn.cluster import KMeans
from sklearn.manifold import TSNE
import plotly.graph_objs as go
import plotly .offline as offline
import plotly.figure_factory as ff

dataset=pd.read_csv('Patches.csv')
dataset

from sklearn.preprocessing import LabelBinarizer
l_bn=LabelBinarizer()
y=dataset['Tree']
dataset['Tree']=l_bn.fit_transform(y)


bins=[100, 2500, 3000, 3500, 4000]
names=[0,1,2,3]
dataset['Elevation']=pd.cut(dataset['Elevation'], bins, labels=names)
dataset = dataset[~dataset['Elevation'].isnull()]


# final conversion now worked
dataset[['Elevation']] = dataset[['Elevation']].astype(int)



bins=[0, 20, 40, 60]
names=[1,2,3]
dataset['Slope']=pd.cut(dataset['Slope'], bins, labels=names)
dataset = dataset[~dataset['Slope'].isnull()]


# final conversion now worked
dataset[['Slope']] = dataset[['Slope']].astype(int)
dataset=dataset.drop(['Horizontal_Distance_To_Roadways'], axis=1)
dataset

# Plotting Correlation Heatmap
corrs = dataset.corr()
figure = ff.create_annotated_heatmap(
         z=corrs.values,
         x=list(corrs.columns),
         y=list(corrs.index),
         annotation_text=corrs.round(2).values,
         showscale=True)
offline.plot(figure,filename='corrheatmap2.html')

dataset.describe()

X=dataset
# Topological Data
subset1 = X[['Elevation','Slope','Tree']]
# Churn factors
subset2 = X[['Elevation','Tree', 'Vertical_Distance_To_Hydrology','Horizontal_Distance_To_Fire_Points']]


feature_scaler = StandardScaler()
X1 = feature_scaler.fit_transform(subset1)
X2 = feature_scaler.fit_transform(subset2)

inertia = []
for i in range(1,11):
    kmeans = KMeans(n_clusters = i, random_state = 100)
    kmeans.fit(X1)
    inertia.append(kmeans.inertia_)

plt.plot(range(1, 11), inertia)
plt.title('The Elbow Plot')
plt.xlabel('Number of clusters')
plt.ylabel('Inertia')
plt.show()


# Running KMeans to generate labels
kmeans = KMeans(n_clusters = 3)
kmeans.fit(X1)

# Implementing t-SNE to visualize dataset
tsne = TSNE(n_components = 2, perplexity=5,n_iter=4000)
x_tsne = tsne.fit_transform(X1)

Elevation = list(X['Elevation'])
Slope = list(X['Slope'])
Tree = list(X['Tree'])

data = [go.Scatter(x=x_tsne[:,0], y=x_tsne[:,1], mode='markers',
                    marker = dict(color=kmeans.labels_, colorscale='Rainbow', opacity=0.5),
                                text=[f'Elevation: {a}; Slope: {b}; Tree:{c}' for a,b,c in list(zip(Elevation, Slope, Tree))],
                                hoverinfo='text')]

layout = go.Layout(title = 't-SNE Dimensionality Reduction', width = 1000, height = 700,
                    xaxis = dict(title='First Dimension'),
                    yaxis = dict(title='Second Dimension'))
fig = go.Figure(data=data, layout=layout)
offline.plot(fig,filename='Patches1.html')

inertia = []
for i in range(1,11):
    kmeans = KMeans(n_clusters = i, random_state = 100)
    kmeans.fit(X2)
    inertia.append(kmeans.inertia_)

plt.plot(range(1, 11), inertia)
plt.title('The Elbow Plot')
plt.xlabel('Number of clusters')
plt.ylabel('Inertia')
plt.show()

# Running KMeans to generate labels
kmeans = KMeans(n_clusters = 2)
kmeans.fit(X2)

# Implementing t-SNE to visualize dataset
tsne = TSNE(n_components = 2, perplexity=50,n_iter=4000)
x_tsne = tsne.fit_transform(X2)

Elevation = list(X['Elevation'])
Tree = list(X['Tree'])
ver_hyd = list(X['Vertical_Distance_To_Hydrology'])
hor_fire=list(X['Horizontal_Distance_To_Fire_Points'])
data = [go.Scatter(x=x_tsne[:,0], y=x_tsne[:,1], mode='markers',
                    marker = dict(color=kmeans.labels_, colorscale='Rainbow', opacity=0.5),
                                text=[f'Elevation: {a}; Tree:{b}; Vertical_Distance_To_Hydrology:{c};Horizontal_Distance_To_Fire_Points:{d}' for a,b,c,d in list(zip(Elevation, Tree,ver_hyd, hor_fire))],
                                hoverinfo='text')]

layout = go.Layout(title = 't-SNE Dimensionality Reduction', width = 1000, height = 700,
                    xaxis = dict(title='First Dimension'),
                    yaxis = dict(title='Second Dimension'))
fig = go.Figure(data=data, layout=layout)
offline.plot(fig,filename='Patches2.html')

